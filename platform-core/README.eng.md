# Platform Core

Core of the execution platform. Contains basic abstractions and logic for building action execution plans.

## Architecture

### Domain Models

- **EntityType** - entity type in the system (Building, Contract, Extract, etc.)
- **Action** - system atom, minimal meaningful operation (order_egrn_extract, close_contract, etc.)
- **State** - entity or system state (for future preconditions/postconditions)
- **UIBinding** - action binding to UI element (selectors, metadata)

### Plan DSL

Execution plan is data, not code:
- Stored in DB
- Serialized
- Edited
- Generated by AI

**Plan** contains:
- Metadata (entityType, entityId, actionId)
- List of steps (PlanStep)
- Execution status

**PlanStep** types:
- `open_page` - open page
- `explain` - explain action
- `hover` - hover over element
- `click` - click element
- `wait` - wait for result
- `type` - type text

### Components

1. **Resolver** - finds EntityType, Action, UIBinding by identifiers
   - Interface: `Resolver`
   - MVP implementation: `InMemoryResolver`

2. **Planner** - builds linear execution plans
   - Accepts `ExecutionRequest`
   - Uses `Resolver` to find components
   - Returns `Plan` with execution steps

3. **ExecutionEngine** - main core component
   - Coordinates Resolver and Planner work
   - Creates execution plans

## Usage

```java
// 1. Create and configure Resolver
InMemoryResolver resolver = new InMemoryResolver();

// Register metadata
EntityType buildingType = new EntityType("Building", "Building", Map.of());
resolver.registerEntityType(buildingType);

Action action = new Action(
    "order_egrn_extract",
    "Order EGRN Extract",
    "Action description",
    Set.of("Building"),
    Map.of()
);
resolver.registerAction(action);

UIBinding uiBinding = new UIBinding(
    "order_egrn_extract",
    "[data-action='order_egrn_extract']",
    UIBinding.SelectorType.CSS,
    Map.of()
);
resolver.registerUIBinding(uiBinding);

// 2. Create Execution Engine
ExecutionEngine engine = new ExecutionEngine(resolver);

// 3. Create request
ExecutionRequest request = new ExecutionRequest(
    "Building",
    "93939",
    "order_egrn_extract",
    Map.of()
);

// 4. Create plan
Plan plan = engine.createPlan(request);
```

## Plan Example

```json
{
  "id": "uuid",
  "entityTypeId": "Building",
  "entityId": "93939",
  "actionId": "order_egrn_extract",
  "status": "CREATED",
  "steps": [
    {
      "type": "open_page",
      "target": "/buildings/93939",
      "explanation": "Opening Building card #93939"
    },
    {
      "type": "explain",
      "explanation": "Orders EGRN extract for building"
    },
    {
      "type": "hover",
      "target": "action(order_egrn_extract)",
      "explanation": "Hovering over action element"
    },
    {
      "type": "click",
      "target": "action(order_egrn_extract)",
      "explanation": "Executing action"
    },
    {
      "type": "wait",
      "target": "result",
      "explanation": "Waiting for action completion"
    }
  ]
}
```

## Principles

1. **UI is source of truth, but not the model**
   - Execute through UI
   - Model through domain abstractions

2. **Platform doesn't know the domain**
   - Any domain is data + metadata, not code

3. **Action is system atom**
   - Action - minimal meaningful operation
   - UI - just action projection

## Evolution

**Stage 1 (MVP)** - current implementation:
- Linear plans
- Manual action registration
- UI-first approach

**Stage 2 (future)** - Reasoning over Actions:
- Preconditions/postconditions
- Applicability checks
- State transitions

**Stage 3 (future)** - Configuration Engine:
- Rules and policies
- Constraints
- Simulations

